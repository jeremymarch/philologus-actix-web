<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width">
    <title>philolog.us</title>
    <meta name="description"
        content="Philologus is a fast, streamlined interface to the online Greek and Latin lexica hosted by the Perseus Project." />
    <meta name="keywords"
        content="Liddell Scott and Jones, Lewis and Short, Slater's Lexicon to Pindar, Perseus Project, Greek, Classical Greek, Ancient Greek, Latin, lexica, lexicon, dictionary, dendrea.org" />
    <script type="text/javascript">
        function setTheme () {
          const mode = window.localStorage.getItem('mode'); // use mode to override system dark mode
          if ((window.matchMedia('(prefers-color-scheme: dark)').matches || mode === 'dark') && mode !== 'light') {
            document.querySelector('HTML').classList.add('dark');
          } else {
            document.querySelector('HTML').classList.remove('dark');
          }
        }
        setTheme();
    </script>
    <style>
        @font-face {
            font-family: 'WebNewAthenaUnicode';
            src: url('/newathu5_8.woff') format('woff'),
                url('/newathu5_8.ttf') format('ttf');
        }

        #mesg { 
          display:none;
          background-color:blue;
          position:absolute;
          z-index:999;
          padding:10px;
          left:10px;
          bottom:10px;
        }

        BODY {
            font-family: NewAthenaUnicode, WebNewAthenaUnicode, helvetica, san-serif;
        }

        BUTTON {
            border-style: none;
        }

        #test1Entry {
            z-index: 999;
        }

        #hamburger {
            z-index: 999;
            position: relative;
        }

        .ftrow {
            border: 1px solid black;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 8px;
            max-height: 200px;
            overflow: auto;
        }

        .dark .ftrow {
            border: 1px solid white;
        }

        .wordtree input {
            font-family: helvetica, arial;
            /*WebNewAthenaUnicode;*/
            font-size: 11pt;
        }

        :root {
            --author-color: red;
            --bib-color: green;
            --ref-color: orange;
            --gloss-color: black;
            --foreign-color: blue;
            --quote-color: blue;
            --foreign-color-dark: #03a5fc;
            --quote-color-dark: #03a5fc;
            --attr-color: blue;
            --attr-color-dark: #03a5fc;

            --author-weight: normal;
            --bib-weight: normal;
            --ref-weight: normal;
            --gloss-weight: bold;
            --foreign-weight: normal;
            --quote-weight: normal;
        }

        .ftrowheaderlink {
            color: blue;
        }

        .dark .ftrowheaderlink {
            color: #03a5fc;
        }

        .ftrowhead {
            padding: 0px;
            margin: 5px 0px;
        }

        /* document.documentElement.style.setProperty("--author-color", "green"); */

        .dark .fo {
            color: blue;
            color: var(--foreign-color-dark, blue);
        }

        .dark .qu {
            color: blue;
            color: var(--quote-color-dark, blue);
        }

        .fo {
            color: blue;
            color: var(--foreign-color, blue);
        }

        .qu {
            color: blue;
            color: var(--quote-color, blue);
        }

        .tr {
            font-weight: bold;
        }

        .au {
            color: red;
            color: var(--author-color, red);
        }

        .bi {
            color: green;
            color: var(--bib-color, green);
        }

        .ti {
            color: orange;
            color: var(--ref-color, orange);
        }

        .biblLink {
            color: green;
            color: var(--bib-color, green);
        }

        .attrlink {
            color: blue;
            color: var(--attr-color, blue);
        }

        .dark .attrlink {
            color: #03a5fc;
            color: var(--attr-color-dark, #03a5fc);
        }

        .dark .defbody {
            color: white;
        }

        .storelink {
            color: blue;
        }

        .dark .storelink {
            color: #03a5fc;
        }

        .qu:before {
            content: '\"';
        }

        .qu:after {
            content: '\"';
        }

        .label {
            font-weight: bold;
            position: absolute;
            left: -36px;
        }

        .label:after {
            content: ' ';
        }

        .orth {
            font-weight: bold;
        }

        #hamburger {
            background-color: white;
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
            height: 30px;
            width: 30px;
        }

        #hamburger rect {
            fill: black;
        }

        .lexitem {
            cursor: pointer;
            text-align: center;
            background-color: white;
            color: black;
            padding: 3px 0px;
            font-size: 8pt;
            font-family: helvetica, arial, sans-serif;
        }

        .lexselected,
        .searchselected {
            background-color: #444;
            color: white;
        }

        .dark .lexselected,
        .dark .searchselected {
            background-color: #444;
            color: white;
            border: 1px solid white;
        }

        .menulink:link {
            color: black;
            text-decoration: none;
        }

        .menulink:visited {
            color: black;
            text-decoration: none;
        }

        .menulink:hover {
            color: black;
            text-decoration: none;
        }

        .menulink:active {
            color: black;
            text-decoration: none;
        }

        .dark .menulink:link {
            color: white;
        }

        .dark .menulink:visited {
            color: white;
        }

        .dark .menulink:hover {
            color: white;
        }

        .dark .menulink:active {
            color: white;
        }

        #settingsdiv div {
            background-color: white;
            color: black;
            display: block;
            padding: 6px 10px;
            cursor: pointer;
            border: 2px solid white;
        }

        #settingsdiv div:hover {
            border: 2px solid black;
        }

        #settingsdiv div:focus {
            border: 2px solid black;
            outline: 0px solid black;
        }

        .dark #settingsdiv div {
            background-color: black;
            color: white;
            display: block;
            padding: 6px 10px;
            cursor: pointer;
            border: 2px solid black;
        }

        .dark #settingsdiv div:hover {
            border: 2px solid white;
        }

        .dark #settingsdiv div:focus {
            border: 2px solid white;
            outline: 0px solid white;
        }

        .menucell {
            text-align: center;
            width: 25%;
            white-space: nowrap;
        }

        .biblLink:link {
            text-decoration: none;
        }

        .biblLink:visited {
            text-decoration: none;
        }

        .biblLink:hover {
            text-decoration: underline;
        }

        .biblLink:active {
            text-decoration: none;
        }

        .bi {
            text-decoration: none;
        }

        HTML {
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: NewAthenaUnicode, WebNewAthenaUnicode;
        }

        .l1 {
            margin-left: 36px;
            position: relative;
        }

        .l2 {
            margin-left: 72px;
            position: relative;
        }

        .l3 {
            margin-left: 108px;
            position: relative;
        }

        .l4 {
            margin-left: 144px;
            position: relative;
        }

        .l5 {
            margin-left: 180px;
            position: relative;
        }

        .body {
            line-height: 1.2;
            margin: 8px 0px
        }

        body,
        html {
            position: fixed;
        }

        #logo {
            color: black;
            z-index: 999;
        }

        .nodestyle {
            line-height: 32px;
            margin: 0px;
            position: relative;
            height: 30px;
            width: calc(100% - 10px);
            white-space: nowrap;
            background-color: white;
            overflow: hidden;
        }

        .nodestylecol {
            position: absolute;
            top: 0px;
        }

        .selectedRowClass {
            background-color: #31408e;
            color: white;
        }

        .WordContainer {
            position: relative;
            left: 11px;
            overflow: auto;
            padding-top: 2px;
            font-size: 12pt;
            font-weight: normal;
            -ms-overflow-style: none;
            /* IE and Edge */
            scrollbar-width: none;
            /* Firefox */
        }

        /* Hide scrollbar for Chrome, Safari and Opera */
        .WordContainer::-webkit-scrollbar {
            display: none;
        }

        .philbody {
            background-color: #eee;
            padding: 0px;
            margin: 0px;
            text-align: center;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        .wordtree {
            margin: 0px;
            background-color: white;
            text-align: left;
            position: relative;
            border-radius: 14px;

        }

        .defbody {
            background-color: white;
        }

        .wordtree input {
            position: absolute;
            top: 40px;
            left: 8px;
            border-radius: 13px;
            border: 2px solid black;
            padding-left: 6px;
            height: 22px;
        }

        .orangetext {
            color: orange;
        }

        .greentext {
            color: green;
        }

        .bluetext {
            color: blue;
        }

        .redtext {
            color: red;
        }

        .boldtext {
            font-weight: bold;
        }

        .blacktext {
            color: black;
        }

        .attrlink {
            color: blue;
        }

        #openHistory {
            color: black;
            position: fixed;
            top: 50%;
            right: 0px;
            writing-mode: vertical-lr;
            background-color: white;
            cursor: pointer;
            padding: 10px 2px;
            font-family: helvetica;
            font-size: 10pt;
            z-index: 900;
            border-radius: 4px;
            display: none;
        }

        .lds-spinner {
            color: official;
            display: inline-block;
            position: relative;
            width: 18px;
            height: 18px;
        }

        .lds-spinner div {
            transform-origin: 40px 40px;
            animation: lds-spinner 1.2s linear infinite;
        }

        .lds-spinner div:after {
            content: " ";
            display: block;
            position: absolute;
            top: 28px;
            left: 39.5px;
            width: 2px;
            height: 6px;
            /*border-radius: 20%;*/
            background: red;
        }

        .lds-spinner div:nth-child(1) {
            transform: rotate(0deg);
            animation-delay: -1.1s;
        }

        .lds-spinner div:nth-child(2) {
            transform: rotate(30deg);
            animation-delay: -1s;
        }

        .lds-spinner div:nth-child(3) {
            transform: rotate(60deg);
            animation-delay: -0.9s;
        }

        .lds-spinner div:nth-child(4) {
            transform: rotate(90deg);
            animation-delay: -0.8s;
        }

        .lds-spinner div:nth-child(5) {
            transform: rotate(120deg);
            animation-delay: -0.7s;
        }

        .lds-spinner div:nth-child(6) {
            transform: rotate(150deg);
            animation-delay: -0.6s;
        }

        .lds-spinner div:nth-child(7) {
            transform: rotate(180deg);
            animation-delay: -0.5s;
        }

        .lds-spinner div:nth-child(8) {
            transform: rotate(210deg);
            animation-delay: -0.4s;
        }

        .lds-spinner div:nth-child(9) {
            transform: rotate(240deg);
            animation-delay: -0.3s;
        }

        .lds-spinner div:nth-child(10) {
            transform: rotate(270deg);
            animation-delay: -0.2s;
        }

        .lds-spinner div:nth-child(11) {
            transform: rotate(300deg);
            animation-delay: -0.1s;
        }

        .lds-spinner div:nth-child(12) {
            transform: rotate(330deg);
            animation-delay: 0s;
        }

        @keyframes lds-spinner {
            0% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        #settingsdiv ul {
            list-style-type: none;
            margin: 0px;
            padding: 0px;
            text-align: left;
        }

        .settings {
            position: absolute;
            top: 70px;
            right: 11px;
            height: 234px;
            width: 230px;
            z-index: 999;
            padding: 10px;
        }

        #settingsdiv {
            background-color: white;
            color: black;
            border: 2px solid black;
            border-radius: 10px;
        }

        .dark #settingsdiv {
            background-color: black;
            color: white;
            border: 2px solid white;
        }

        .dark #settingsdiv li {
            color: white;
        }

        .dark #hamburger {
            background-color: black;
        }

        .dark #hamburger rect {
            fill: white;
        }

        .dark .lds-spinner div:after {
            background: #fff;
        }

        .dark #logo {
            color: white;
        }

        .dark .philbody {
            background-color: black;
        }

        .dark .wordtree {
            background-color: #202124;
        }

        .dark .wordtree .nodestyle {
            background-color: #202124;
            color: white;
            border:1px solid #202124;
        }

        .dark .nodestyle.selectedRowClass {
            background-color: #444;
            border: 1px solid white;
            color: white;
        }

        .dark .defbody {
            background-color: #202124;
        }

        .dark .wordtree input {
            background-color: #202124;
            border: 2px solid white;
            color: white;
        }

        #topmenu {
            visibility: hidden;
        }

        #backdrop {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 100%;
            height: 100%;
            z-index: 900;
        }

        #leftlist {
            background-color: white;
        }

        .dark #leftlist {
            background-color: #202124;
        }

        #defbody {
            transition: .75s;
            border-radius: 14px;
            position: relative;
            z-index: 1;
            top: 50px;
            margin-left: 280px;
            margin-right: 10px;
            overflow: hidden;
            height: calc(100% - 80px);
            text-align: left;
        }

        #lsjdef {
            transition: .75s;
            position: relative;
            z-index: 2;
            margin: 0px;
            padding: 10px;
            overflow: auto;
            height: calc(100% - 20px);
        }

        .fulltext #defbody {
            transition: .75s;
            margin-left: 10px;
            top: -10px;
            height: calc(100% - 18px);
        }

        .fulltext #lsjdef {
            transition: .75s;
            top: 62px;
            height: calc(100% - 100px);
        }

        #test1Entry {
            transition: .75s;
            width: 193px;
        }

        #test1Loading {
            transition: .75s;
            right: 35px;
        }

        .fulltext #test1Loading {
            transition: .75s;
            right: -51px;
        }

        .fulltext #test1Entry {
            transition: .75s;
            width: 256px;
        }

        #test1FTCheck {
            z-index: 999;
        }

        LABEL {
            color: black;
        }

        .dark LABEL {
            color: white;
        }
    </style>
</head>

<body onload="start()" class="philbody">

    <div id="taglist" style="position:absolute;top:0px;left:0px;height:50%;width:220px;display:none;"></div>
    <div id="historylist" style="position:absolute;top:50%;left:0px;height:50%;width:220px;display:none;"></div>
    <div id="leftlist"
        style="position:absolute;top:0px;left:0px;height:calc(100% - 20px);width:259px;margin:10px;border-radius: 14px;">
    </div>
    <!--<div id="openHistory">History</div>-->
    <div id="rightlist" style="position:absolute;top:69px;right:20px;width:260px;height:500px;">
        <!--<div style="border:1px solid black;margin-top:40px;padding:5px;text-align:left;" id="message1">The site has been updated with new code and data.    Please report any problems you might have with the update to <a href="mailto:jmarch@gradcenter.cuny.edu">jmarch@gradcenter.cuny.edu</a>.    The previous version is available <a href="http://philolog.us/v1">here</a> if you need it.<br><br><div style="width:100%;text-align:center;"><a href="javascript:closeMessage()">close</a></div></div>
    -->
        <div id="taglistRight" style="position:absolute;top:0px;left:0px;height:50%;width:220px;"></div>
        <div id="historylistRight" style="position:absolute;top:50%;left:0px;height:50%;width:220px;"></div>
    </div>

    <div id="topmenu"
        style="color:#888;font-size:10pt;padding-top:3px;padding-bottom:0px;position:relative;z-index:1;top:4px;margin-left:280px;margin-right:280px;overflow:hidden;border-bottom:1px solid #CCC;text-align:left;">
        <div style="width:100%;display:flex;">
            <div class='menucell'><a href='javascript:contact()' class="menulink">about</a></div>
            <div class='menucell'><a href='javascript:showiPhone()' class="menulink">mobile app</a></div>
            <div class='menucell'><a href='javascript:config()' class="menulink">configure</a></div>
            <dov class='menucell'><a href='javascript:toggleHistoryChooser()' class="menulink">toggle history</a>
        </div>
        <!--<td class='menucell'><a href='javascript:toggleTagList()' class="menulink">tags</a></td>
    <td class='menucell' style="width:20%;"><span id="userNameField"></span><a id="loginLink" href='javascript:toggleLogin()' class="menulink">login</a></td>
-->
    </div>
    </div>

    <div id="defbody" class="defbody">
        <div id="lsjdef" ontouchstart="onTouch(event)"></div>
    </div>

    <div
        style="position:absolute;top:0px;right:0px;height:48px;border:0px solid green;text-align:center;letter-spacing:normal;display:flex;">
        <div id="logo"
            style="padding: 0px 15px;text-align:center;position:relative;top:16px;font-size:28pt;font-family:helvetica,arial,sans-serif;">
            philolog.us</div>
        <div style="padding-top:18px;padding-right:10px;">
            <div>

                <svg onclick="toggleSettings()" id="hamburger" viewBox="0 0 120 120">
                    <rect x="10" y="30" width="100" height="12"></rect>
                    <rect x="10" y="56" width="100" height="12"></rect>
                    <rect x="10" y="82" width="100" height="12"></rect>
                </svg>
            </div>
        </div>
    </div>
    <div id="mesg"></div>
    <script type="text/javascript">
        'use strict';

        const setURLToWordId = true;
        // https://github.com/le717/microajax
        function microAjax (options) {
          'use strict';

          // Default to GET
          if (!options.method) {
            options.method = 'GET';
          }

          // Default empty functions for the callbacks
          function noop () { }
          if (!options.success) {
            options.success = noop;
          }
          if (!options.warning) {
            options.warning = noop;
          }
          if (!options.error) {
            options.error = noop;
          }

          const request = new XMLHttpRequest();
          request.open(options.method, options.url, true);
          request.send(options.data);

          request.onload = function () {
            // Success!
            if (request.readyState === 4 && request.status === 200) {
              options.success(request.responseText);

              // We reached our target destination, but it returned an error
            } else {
              options.warning(request.responseText);
            }
          };

          // There was a connection error of some sort
          request.onerror = options.error;
        }

        window.addEventListener('popstate', function (e) {
          // exclude from history, else we push it back on at same time as popping.
          // see defjson.js: end of setWord.
          if (e.state && e.state.length > 1) {
            getDef(e.state[0], e.state[1], '', true, false);
          }
        }, false);

        const useRight = true;
        const lex = ['lsj', 'slater', 'ls'];

        function closeHistoryChooser () {
          historyOpen = false;
          const hist = lookupWT('test4');
          if (!hist) {
            return;
          }

          hist.close();
          document.getElementById('test1Entry').focus();
        }

        function fullTextRequest (query) {
          const ftURL = 'ft/?q=' + query;
          microAjax({
            url: ftURL,
            method: 'GET',
            success: procFTResponse,
            warning: procFTResponseError,
            error: null
          });
        }

        function procFTResponse (str, status) {
          const wt = lookupWT('test1');
          wt.loading.style.display = 'none';
          let returnObj = {};
          try {
            if (typeof JSON !== 'undefined') {
              returnObj = JSON.parse(str);
            } else {
              return;
            }
          } catch (e) { if (debug) console.log(e.message + '\n' + str); return; };

          if (!returnObj) {
            return;
          }

          // console.log("found " + returnObj.num + " items, returned " + returnObj.ftresults.length + " items");

          let rows = '';
          let i = 0;
          for (; i < returnObj.ftresults.length; i++) {
            let lex = '';
            if (returnObj.ftresults[i].lex === 'greatscott') {
              lex = 'LSJ';
            } else if (returnObj.ftresults[i].lex === 'latindico') {
              lex = 'LS';
            } else if (returnObj.ftresults[i].lex === 'pindar_dico') {
              lex = 'Slater';
            } else {
              lex = returnObj.ftresults[i].lex;
            }
            // getDef(cols[1], lexicon, "", false, true);
            rows += "<div class='ftrow'><p class='ftrowhead'><a class='ftrowheaderlink' href='javascript:getDef(" + returnObj.ftresults[i].id + ', "' + lex.toLowerCase() + "\", false, true)'>" + lex + ': ' + returnObj.ftresults[i].lemma + '</a></p>' + returnObj.ftresults[i].def + '</div>';
          }

          const con = document.getElementById('lsjdef');
          // if (data.errorMesg) {
          //     con.innerHTML = "<div id='lsj222' style='padding:40px 18px;text-align:center;'>" + data.errorMesg + "</div>";
          //     return;
          // }
          con.innerHTML = "<div id='lsj222' style='padding:10px 18px;'><div style='font-size:14pt;margin-top:6px;margin-bottom:4px;'>Full-text search results: </div><div style='margin-bottom:24px;'></div>" + rows + '</div>'; // the firstChild is the CDATA node
          con.scrollTo(0, 0);
        }

        function procFTResponseError (str) {
          const wt = lookupWT('test1');
          wt.loading.style.display = 'none';
        }

        function toggleHistoryChooser () {
          if (historyOpen) {
            // document.getElementById("openHistory").style.display = "block";
            closeHistoryChooser();
            document.getElementById('defbody').style.marginRight = '10px';

            setLocalStorageKey('historylist', '0');
          } else {
            // document.getElementById("openHistory").style.display = "none";
            historyChooser();
            document.getElementById('defbody').style.marginRight = '280px';

            if (supportsHTML5Storage()) {
              const h = window.localStorage.getItem('history2');
              if (w4 && h && h.length > 0) {
                w4.refreshWithRows(h);
              }
            } else {
              document.getElementById('defbody').style.marginRight = '10px';
            }
            setLocalStorageKey('historylist', '1');
            onResize();
          }
        }

        function historyChooserOnSelect (lexicon, cols) {
          // col2 is the lexicon # from history
          let lex;
          if (cols[2] === 0) {
            lex = 'lsj';
          } else if (cols[2] === 1) {
            lex = 'slater';
          } else {
            lex = 'ls';
          }

          getDef(cols[1], lex, '', true, true);
        }

        let historyOpen = false;
        let w4;

        function historyChooser () {
          if (historyOpen) {
            return;
          }

          const h = getViewportHeight(window);

          historyOpen = true;
          const d = document.getElementById('historylist');

          document.getElementsByTagName('body')[0].appendChild(d);

          w4 = new Wordtree('test4', 260, h - 20);
          w4.conTopOffset = 38;
          w4.con.style.top = w4.conTopOffset + 'px';
          w4.setHeight(w4.height);
          w4.div.style.zIndex = 800;

          w4.div.style.borderRadius = '14px';
          w4.div.style.margin = '10px';
          w4.div.style.marginTop = '0px';

          w4.title.innerHTML = '<div style="width:' + (w4.width - 14) + 'px;"><div class="lexitem">History</div></div>';
          w4.url = 'historyserv.php';
          w4.entry.style.left = '-4000px';
          w4.onSelectionChanged = historyChooserOnSelect;

          w4.onClickActivate = historyChooserOnSelect;
          w4.onAddWord = null;
          w4.onDeleteWord = null; // deleteTag;

          if (useRight) {
            w4.show(document.getElementById('rightlist')); // w4.show(document.getElementById("historylistRight"));
          } else {
            w4.show(d);
          }
        }

        function globalKeyUp (ev) {
          const key = ev.keyCode;
          if (!ev.metaKey && !ev.ctrlKey && !ev.shiftKey && !ev.altKey) {
            if (key === 27) { // esc
              const w = lookupWT('test1');
              w.entry.focus();
              ev.returnValue = false;
              ev.preventDefault();
            }
          }
        }

        function globalKeyDown (ev) {
          const key = ev.keyCode;
          if (!ev.metaKey && !ev.ctrlKey && !ev.shiftKey && !ev.altKey) {
            if (key === 49) { // 1
              switchLex(0);
              ev.returnValue = false;
              ev.preventDefault();
            } else if (key === 50) { // 2
              switchLex(1);
              ev.returnValue = false;
              ev.preventDefault();
            } else if (key === 51) { // 3
              switchLex(2);
              ev.returnValue = false;
              ev.preventDefault();
            }
          }
          return true;
        }

        function onClickRow (lexicon, cols) {
          // console.log("get def: " + cols[1] + ", " + lexicon);
          getDef(cols[1], lexicon, '', false, true);
        }

        document.onkeydown = globalKeyDown;
        document.onkeyup = globalKeyUp;

        // eslint-disable-next-line no-unused-vars
        function start () {
          const matches = window.location.pathname.match(/\/(lsj|ls|slater)\/?([^/]*)\/?$/);
          let startLex = 'lsj';
          let startWord = '';

          if (matches && setURLToWordId) {
            startLex = matches[1];
            if (matches[2]) {
              startWord = matches[2];
              getDefFromWordid(startWord, startLex, '', true, true);
            }
          }

          if (!getLocalStorageKey('filter')) {
            setLocalStorageKey('filter', 'red:bold:blue:blue:green:orange');
          }

          let oldlex = getLocalStorageKey('lex');
          oldlex = oldlex || lex[0];
          if (startLex) {
            oldlex = startLex;
          }
          const winHeight = getViewportHeight(window);

          const w = new Wordtree('test1', 260, winHeight - 36);
          w.show(document.getElementById('leftlist'));

          const showHist = getLocalStorageKey('historylist');
          if (supportsHTML5Storage() && showHist && showHist === 1) {
            toggleHistoryChooser();
            document.getElementById('defbody').style.marginRight = '280px';
          } else {
            document.getElementById('defbody').style.marginRight = '10px';
          }

          w.cache = [];
          w.params.regex = 0;
          w.params.lexicon = lex[0];
          w.params.tag_id = 0;
          w.params.root_id = 0;
          if (startWord) {
            w.params.wordid = startWord;
          }

          w.conTopOffset = 98;
          w.con.style.top = w.conTopOffset + 'px';

          document.getElementById('test1Entry').focus();

          w.title.innerHTML = '<div style="margin-left:4px;width:' + (w.width - 18) + 'px;display:flex;"><BUTTON id="lexlabel0" class="lexitem" style="width:31%;" onclick="switchLex(0)">LSJ</BUTTON><BUTTON id="lexlabel1" class="lexitem" style="width:33%;" onclick="switchLex(1)">Slater</BUTTON><BUTTON id="lexlabel2" class="lexitem" style="width:36%;" onclick="switchLex(2)">Lewis &amp; Short</BUTTON></div><div style="margin-left:4px;width:' + (w.width - 18) + 'px;display:flex;"><BUTTON id="searchlabel0" class="lexitem" style="width:50%;" onclick="switchSearch(0)">Lemma</BUTTON><BUTTON id="searchlabel1" class="lexitem" style="width:50%;" onclick="switchSearch(1)">Full-text</BUTTON></div>';

          // https://stackoverflow.com/questions/16242980/making-radio-buttons-look-like-buttons-instead
          // let title = '<div style="margin-left:4px;width:' + (w.width - 18) + 'px;display:flex;">\
          // <input id="lexlabel0" onclick="switchLex(0)" aria-label="LSJ" class="lexitem" type="radio" name="lex_radio" value="lsj" checked>LSJ</input>\
          // <input id="lexlabel1" onclick="switchLex(1)" aria-label="Slater" class="lexitem" type="radio" name="lex_radio" value="slater">Slater</input>\
          // <input id="lexlabel2" onclick="switchLex(2)" aria-label="Lewis & Short" class="lexitem" type="radio" name="lex_radio" value="ls">Lewis &amp; Short</input></div>';

          w.mode = 'context';
          w.onAddWord = null;// addWordToList;
          w.onDeleteWord = null;// deleteTag;
          w.onEnterActivate = null;// addWordToList;
          w.onClickActivate = onClickRow;
          w.onSelectionChanged = onClickRow;

          let lexNum = 0;
          for (; lexNum < lex.length; lexNum++) {
            if (oldlex === lex[lexNum]) {
              switchLex(lexNum);
              break;
            }
          }
          switchSearch(0);

          // reset after querying
          w.params.wordid = '';
          delete w.params.wordid;
          window.onresize = onResize; // $(window).resize(onResize);

          onResize();
        }

        function onResize () {
          const height = getViewportHeight(window);

          const w = lookupWT('test1');

          w.setHeight(height - 14);

          // let defbody = document.getElementById("defbody");
          // defbody.style.height = h - 80 + "px";

          // let lsjdef = document.getElementById("lsjdef");
          // lsjdef.style.height = (h - 110) + "px";

          const rl = document.getElementById('rightlist');
          if (rl) {
            rl.style.height = (height - 58) + 'px';
          }
          const historyList = lookupWT('test4');
          if (historyList) {
            historyList.setHeight(height - 74);
          }
        }

        let fullText = false;

        function switchSearch (num) {
          document.getElementById('lsjdef').innerHTML = '';
          const wt = lookupWT('test1');
          wt.entry.value = '';

          const a = document.querySelector('.searchselected');
          if (a) {
            a.classList.remove('searchselected');
          }

          if (num === 0) {
            fullText = false;
            wt.refresh();
          } else {
            fullText = true;
          }

          const b = document.getElementById('searchlabel' + num);
          if (b) {
            b.classList.add('searchselected');
          }
        }

        function switchLex (num) {
          const wt = lookupWT('test1');
          if (wt) {
            wt.entry.value = '';
            wt.params.lexicon = lex[num];
            wt.refresh();

            const a = document.querySelector('.lexselected');
            if (a) {
              a.classList.remove('lexselected');
            }

            const b = document.getElementById('lexlabel' + num);
            if (b) {
              b.classList.add('lexselected');
            }

            if (wt.entry) {
              wt.entry.focus();
            }
            setLocalStorageKey('lex', lex[num] ? lex[num] : lex[0]);
          }
        }

        // eslint-disable-next-line no-unused-vars
        function contact () {
          const about = "Philolog.us first launched in June 2005 shortly after the Perseus Digital Library began offering access to its collections via web services. One of the primary aims has been to offer a streamlined, user-friendly interface to the lexica in the Perseus library.<br/><br/><br/>Thanks to the <a class='storelink' href='http://www.perseus.tufts.edu'>Perseus Digital Library</a> for digitizing and make available these texts.    Thanks also to <a class='storelink' href='https://logeion.uchicago.edu'>Logeion</a> for making many corrections and improvements to them. <br/><br/>Jeremy March<br/><a class='storelink' href='mailto:jmarch@gradcenter.cuny.edu'>jmarch@gradcenter.cuny.edu</a>";
          document.getElementById('lsjdef').innerHTML = "<div style='text-align:left;margin:10px;'>" + about + '</div>';
        }

        // eslint-disable-next-line no-unused-vars
        function showiPhone () {
          const news = "Available for iPhone/iPad app in the <a href='https://itunes.apple.com/us/app/philolog.us/id622324932?mt=8' class='storelink'>App store</a>.<br><br><br>Available for Android in the <a href='https://play.google.com/store/apps/details?id=com.philolog.philologus&hl=en' class='storelink'>Google Play store</a>.";
          document.getElementById('lsjdef').innerHTML = "<div style='text-align:center;font-size:16pt;padding-top:60px;'>" + news + '</div>';
        }

        // eslint-disable-next-line no-unused-vars
        function config () {
          window.location = 'configure.html';
        }

        // eslint-disable-next-line no-unused-vars
        function closeMessage () {
          const a = document.getElementById('message1');
          if (a) {
            a.style.display = 'none';
          }
        }

        const la = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
        const gr = ['α', 'β', 'ψ', 'δ', 'ε', 'φ', 'γ', 'η', 'ι', 'ξ', 'κ', 'λ', 'μ', 'ν', 'ο', 'π', '', 'ρ', 'σ', 'τ', 'θ', 'ω', 'ς', 'χ', 'υ', 'ζ', 'Α', 'Β', 'Ψ', 'Δ', 'Ε', 'Φ', 'Γ', 'Η', 'Ι', 'Ξ', 'Κ', 'Λ', 'Μ', 'Ν', 'Ο', 'Π', '', 'Ρ', 'Σ', 'Τ', 'Θ', 'Ω', 'Σ', 'Χ', 'Υ', 'Ζ'];
        const forceLowercase = true;
        function transliterate (char) {
          const theChar = (forceLowercase) ? char.toLowerCase() : char;
          const idx = la.indexOf(theChar);
          if (idx > -1) {
            return gr[idx];
          } else {
            return char;
          }
        }

        function transliterateKey (evt) {
          const source = evt.target || evt.srcElement;
          const val = source.value;
          const charCode = typeof (evt.which) === 'number' ? evt.which : evt.keyCode;

          if (charCode && charCode > 64 && charCode < 123 && !fullText) { // letter
            const start = source.selectionStart;
            const end = source.selectionEnd;
            const key = String.fromCharCode(charCode);

            const mappedChar = transliterate(key);
            const charsToReplace = 0;
            source.value = val.slice(0, start - charsToReplace) + mappedChar + val.slice(end);
            // Move the caret
            source.selectionStart = source.selectionEnd = start + 1 - charsToReplace;
            return false;
          }
          return true;
        }

        function getViewportHeight (w) {
          if (typeof (w.innerHeight) !== 'undefined') {
            return w.innerHeight;
          } else if (w.document.compatMode === 'CSS1Compat') {
            return w.document.documentElement.clientHeight;
          } else if (w.document.body) {
            return w.document.body.clientHeight;
          } else {
            return window.undefined;
          }
        }

        function setLocalStorageKey (name, value) {
          if (typeof (window.localStorage) !== 'undefined') {
            window.localStorage.setItem(name, value);
          }
        }

        function getLocalStorageKey (name) {
          if (typeof (window.localStorage) !== 'undefined') {
            const value = window.localStorage.getItem(name);
            return value;
          }
          return null;
        }

        // eslint-disable-next-line no-unused-vars
        function toggleSettings () {
          let settingsDiv = document.getElementById('settingsdiv');
          if (!settingsDiv) {
            settingsDiv = document.createElement('div');
            settingsDiv.id = 'settingsdiv';
            settingsDiv.classList.add('settings');
            settingsDiv.style.display = 'block';
            settingsDiv.innerHTML = "Settings<br><ul><li><div tabindex='0' onclick='contact()' class='menulink'>about</div></li><li><div tabindex='0' onclick='showiPhone()' class='menulink'>iOS/Android app</div></li><!--<li><div tabindex='0' onclick='config()' class='menulink'>configure</div></li>--><li><div tabindex='0' onclick='toggleHistoryChooser()' class='menulink'>show/hide history</div></li><li><div tabindex='0' style='height:70px;'>dark mode: <div style='text-align:right;float:right;padding:0px;border:none;'><label for='darkModeSystem'>system</label> <input id='darkModeSystem' type='radio' name='darkmode' onclick='darkModeClick(this);' value='system'/><br><label for='darkModeDark'>dark</label> <input id='darkModeDark' type='radio' name='darkmode' onclick='darkModeClick(this);' value='dark'/><br><label for='darkModeLight'>light</label><input id='darkModeLight' type='radio' name='darkmode' onclick='darkModeClick(this);' value='light'/></div></div></li></ul>";
            const noclick = document.createElement('div');
            noclick.id = 'backdrop';
            noclick.onclick = function () {
              document.querySelector('#backdrop').style.display = 'none';
              toggleSettings();
            };
            document.body.appendChild(noclick);
            document.body.appendChild(settingsDiv);
          } else if (settingsDiv.style.display === 'block') {
            document.querySelector('#backdrop').style.display = 'none';
            settingsDiv.style.display = 'none';
          } else {
            document.querySelector('#backdrop').style.display = 'block';
            settingsDiv.style.display = 'block';
          }

          const mode = window.localStorage.getItem('mode');
          switch (mode) {
            case 'dark':
              document.querySelector('#darkModeDark').checked = true;
              break;
            case 'light':
              document.querySelector('#darkModeLight').checked = true;
              break;
            default:
              document.querySelector('#darkModeSystem').checked = true;
              break;
          }
        }

        // eslint-disable-next-line no-unused-vars
        function darkModeClick (radio) {
          switch (radio.value) {
            case 'dark':
              window.localStorage.setItem('mode', 'dark');
              break;
            case 'light':
              window.localStorage.setItem('mode', 'light');
              break;
            default:
              window.localStorage.removeItem('mode');
              break;
          }
          // eslint-disable-next-line no-undef
          setTheme();
        }

        const defCache = [];
        let defCacheLength = 0;
        const defCacheLimit = 500;
        const useDefCache = true;
        let vSaveHistory = true;
        let vAddToBackHistory = true;

        function getDef (id, lexicon, word, excludeFromHistory, pushToBackHistory) {
          const skipCache = 0;
          const addWordLinks = 0;

          if (excludeFromHistory) { vSaveHistory = false; } else { vSaveHistory = true; }

          if (pushToBackHistory) { vAddToBackHistory = true; } else { vAddToBackHistory = false; }

          // the random number id needed for ie--it would ask for the same page twice
          const url = 'item?id=' + id + '&lexicon=' + lexicon + '&skipcache=' + skipCache + '&addwordlinks=' + addWordLinks + '&x=' + Math.random();
          // console.log("get def: " + url);

          if (!useDefCache || !defCheckCache(lexicon, id)) {
            loadXMLDoc(url);
          }
          // document.getElementById("lsjdef").innerHTML = "<center>Loading...</center>";
        }

        function getDefFromWordid (wordid, lexicon, word, excludeFromHistory, pushToBackHistory) {
          const skipCache = 0;
          const addWordLinks = 0;

          if (excludeFromHistory) { vSaveHistory = false; } else { vSaveHistory = true; }

          if (pushToBackHistory) { vAddToBackHistory = true; } else { vAddToBackHistory = false; }

          // the random number id needed for ie--it would ask for the same page twice
          const url = 'item?wordid=' + wordid + '&lexicon=' + lexicon + '&skipcache=' + skipCache + '&addwordlinks=' + addWordLinks + '&x=' + Math.random();

          // if (!useDefCache || !defCheckCache(lexicon, id))
          loadXMLDoc(encodeURI(url));

          // document.getElementById("lsjdef").innerHTML = "<center>Loading...</center>";
        }

        // for saving history to database
        let lastId = -1;
        function setWord (json, status) {
          let data;
          // str = resp2;
          // alert(json);
          try {
            if (typeof JSON !== 'undefined') {
              data = JSON.parse(json);
            } else {
              return; // data = eval("(" + json + ")");
            }
          } catch (e) {
            // if (debug) console.log(e.message + "\n" + json);
            return;
          };

          if (!data) {
            return;
          }

          const con = document.getElementById('lsjdef');

          if (data.errorMesg) {
            con.innerHTML = "<div id='lsj222' style='padding:40px 18px;text-align:center;'>" + data.errorMesg + '</div>';
            return;
          }

          const def = data.def;
          const lexicon = data.lexicon;
          const id = data.word_id;
          const word = data.word.replace(/[0-9]/g, ''); // strip number, if any, from end of string
          const wordid = data.word;
          const lemma = data.lemma;
          let pps = data.principalParts;

          document.title = word;

          pps = (pps && pps.length > 0) ? pps : '';

          const perseusLink = "<a href='http://www.perseus.tufts.edu/hopper/text.jsp?doc=Perseus:text:";

          let attr = "<br/><br/><div id='attrib' style='text-align:center;'>";
          if (lexicon === 'lsj') {
            attr += perseusLink + "1999.04.0057' class='attrlink'>Liddell, Scott, and Jones</a> ";
            attr += perseusLink + '1999.04.0057%3Aentry%3D';
          } else if (lexicon && lexicon === 'slater') {
            attr += perseusLink + "1999.04.0072' class='attrlink'>Slater's <i>Lexicon to Pindar</i></a> ";
            attr += perseusLink + '1999.04.0072%3Aentry%3D';
          } else if (lexicon && lexicon === 'ls') {
            attr += perseusLink + "1999.04.0059' class='attrlink'>Lewis and Short</a> ";
            attr += perseusLink + '1999.04.0059%3Aentry%3D';
          }
          attr += escape(lemma);
          attr += "' class='attrlink'>entry</a> courtesy of the<br/>";
          attr += "<a href='http://www.perseus.tufts.edu' class='attrlink'>Perseus Digital Library</a>";
          attr += '</div>';
          // attr += "</div>";

          con.innerHTML = "<div id='lsj222'    style='padding:10px 18px;'><div style='font-size:20pt;margin-bottom:16px;'>" + word + "</div><div style='margin-bottom:24px;'>" + pps + '</div>' + def + attr + '</div>'; // the firstChild is the CDATA node
          con.scrollTo(0, 0);

          if (useDefCache) {
            defAddResultToCache(lexicon, id, json);
          }

          if (vSaveHistory) {
            lastId = id;
            // setTimeout("saveHistory('" + lexicon + "'," + id + ", '" + word + "')", 1500);
            setTimeout(function () {
              saveHistory(lexicon, id, word);
            }, 1500);
          }

          if (vAddToBackHistory) {
            if (window.history && typeof (window.history.pushState) === 'function') {
              // add lexicon and word to path
              if (setURLToWordId) {
                window.history.pushState([id, lexicon], wordid, getPathBeforeLexicon(window.location.pathname) + lexicon + '/' + wordid);
              }
            }
          }
        }

        function getPathBeforeLexicon (loc) {
          // get path before any lsj/ls/slater; this makes it work on subdirectories
          let phPath = '';
          const a = loc.indexOf('/lsj');
          if (a > -1) {
            phPath = loc.substring(0, a) + '/';
          } else {
            const a = loc.indexOf('/ls');
            if (a > -1) {
              phPath = loc.substring(0, a) + '/';
            } else {
              const a = loc.indexOf('/slater');
              if (a > -1) {
                phPath = loc.substring(0, a) + '/';
              }
            }
          }
          // console.log(phPath);
          return phPath;
        }

        function supportsHTML5Storage () {
          try {
            return 'localStorage' in window && window.localStorage !== null;
          } catch (e) {
            return false;
          }
        }

        function saveHistory (lexicon, id, word) {
          // alert(lexicon + ", " + id);
          if (id === lastId) {
            if (supportsHTML5Storage()) {
              let lexi = 0;
              if (lexicon === lex[0]) { lexi = 0; } else if (lexicon === lex[1]) { lexi = 1; } else { lexi = 2; }

              const hist = window.localStorage.getItem('history2');
              let tree = null;
              if (hist && hist.length > 0) {
                tree = JSON.parse(hist);
              } else {
                tree = {
                  error: '',
                  wtprefix: 'test4',
                  container: 'test4Container',
                  requestTime: '1427555297518',
                  selectId: '-1',
                  page: '0',
                  lastPage: '1',
                  lastPageUp: '1',
                  scroll: '',
                  query: '',
                  arrOptions: []
                };
              }

              if (tree.arrOptions.length < 1 || id !== tree.arrOptions[0][1]) {
                tree.arrOptions.splice(0, 0, [word, id, lexi]);
              }

              const max = 500;
              if (tree.arrOptions.length > max) {
                const toRemove = tree.arrOptions.length - max;
                tree.arrOptions.splice(tree.arrOptions.length - toRemove, toRemove);
              }

              const h = JSON.stringify(tree);

              window.localStorage.setItem('history2', h);
              if (w4) {
                w4.refreshWithRows(h);
              }
            }
          }
        }

        function loadXMLDoc (url) {
          microAjax({
            url,
            method: 'GET',
            success: setWord,
            warning: null,
            error: null
          });
        }

        function defCheckCache (lexicon, queryKey) {
          queryKey = lexicon + queryKey;
          if (defCache && defCache[queryKey]) {
            // alert("here");
            setWord(defCache[queryKey].str);
            return true;
          } else {
            return false; // not cached, request it
          }
        }

        function defAddResultToCache (lexicon, queryKey, str) {
          queryKey = lexicon + queryKey;

          // if this query isn't in the cache
          if (!defCache[queryKey]) {
            // if we're at the cacheLimit remove the oldest item
            // use cacheLength because assoc arrays have no length property and we don't want to have to count them each time
            if (defCacheLimit && defCacheLength >= defCacheLimit) {
              let prev = null;
              let x;
              for (x in defCache) {
                if (typeof defCache.hasOwn === 'function' && !defCache.hasOwn(x)) { continue; }

                if (prev == null || defCache[x].time < defCache[prev].time) { prev = x; }
              }
              if (prev) {
                defCacheLength--;
                delete defCache[prev];
              }
            }
            defCacheLength++;
            defCache[queryKey] = [];
            defCache[queryKey].str = str;
            defCache[queryKey].time = new Date().getTime();
          } else {
            // if it is in the cache, update the timestamp
            defCache[queryKey].time = new Date().getTime();
          }
        }
        /* end defjson.js */
        /* start wordtree.js */

        const globalWordTrees = [];

        /* global */
        const keyDelay = 350; // to prevent each key press from triggering a query for fast typers
        const cacheLimit = 500;
        const debug = false;
        // const mouseWheelSpeedFactor = 10; // between 4 and 12 seem to work best
        const keyScrollAccel = 4;

        let platform;
        if (window.navigator.userAgent.indexOf('iPhone') !== -1) { platform = 'iphone'; } else if (window.navigator.userAgent.indexOf('iPad') !== -1) { platform = 'ipad'; } else if (window.navigator.platform.toLowerCase().indexOf('mac') !== -1) { platform = 'mac'; } else if (window.navigator.platform.toLowerCase().indexOf('linux') !== -1) { platform = 'linux'; } else { platform = 'windows'; }

        function lookupWT (idPrefix) {
          for (let i = 0; i < globalWordTrees.length; i++) {
            if (globalWordTrees[i][0] === idPrefix) { return globalWordTrees[i][1]; }
          }

          return null;
        }

        function destroyWT () {
          const p = this.div.parentNode;
          p.removeChild(this.div);

          for (let i = 0; i < globalWordTrees.length; i++) {
            if (globalWordTrees[i][0] === this.idPrefix) {
              globalWordTrees.splice(i, 1);
              break;
            }
          }
          return null;
        }

        function Wordtree (idPrefix, width, height) {
          this.mode = 'context';
          this.asYouType = true;
          this.width = width;
          this.bgcolor = '#ffffff';
          this.selectedRow = null;
          this.accelTimeout = null;
          this.lastRequestTime = null;
          this.lastKeyTimeout = null;
          this.indentWidth = 15; // for tree branches
          this.conTopOffset = 79;

          /*
            At first we were using the system default rate for scrolling when
            the arrow keys were held down.    It might be more consistent across
            systems and smoother to use a timer to control how fast scrolling
            occurs.
            */
          this.scrollTimer = false; // whether to use the scroll timer or the old way
          this.scrollTimerKeyDown = false;
          this.scrollTimerTimeout = null;
          this.scrollTimerDelay = 1500; // time before the timer is invoked
          this.scrollTimerRate = 100; // rate of scroll
          this.scrollTimerStep = 1; // step of scroll

          this.step = 1;

          // whether to automatically focus the entry when wt "has focus", disable for iphones, ipads, etc.
          if (platform === 'ipad' || platform === 'iphone' || (navigator.maxTouchPoints && navigator.maxTouchPoints > 1)) { this.autofocus = false; } else { this.autofocus = true; }

          this.maxWords = 100;
          this.url = 'query';
          this.idPrefix = idPrefix;

          this.params = {};

          this.columnOffsets = [0, 0, 0];
          this.columns = 1;

          this.rowCount = 0;
          this.pageUp = 0; // for scrolling up
          this.page = 0; // for scrolling down
          this.nextPageRequestPending = false;
          this.prevPageRequestPending = false;
          this.lastPage = false;
          this.lastPageUp = false;
          this.blockScroll = false; // fixes a bug in webkit where next page was requested while loading 0 page

          const d = document.createElement('div');
          this.div = d;
          d.id = idPrefix;
          d.classList.add('wordtree');

          const ti = document.createElement('div');
          ti.style.position = 'absolute';
          ti.style.top = '17px';
          ti.style.left = '6px';
          ti.style.width = this.width - 33 + 'px';
          ti.innerHTML = 'Title';
          this.title = ti;

          this.div.appendChild(ti);

          const input = document.createElement('input');
          input.ariaLabel = 'Enter prefix for word';
          input.style.width = this.width - 67 + 'px';
          input.style.position = 'absolute';
          input.style.top = '66px';
          input.style.left = '12px';
          input.setAttribute('autocomplete', 'off');
          input.setAttribute('autocorrect', 'off');
          input.setAttribute('autocapitalize', 'off');
          input.setAttribute('spellcheck', 'false');
          // input.setAttribute("lang", "gr");
          input.id = idPrefix + 'Entry';
          this.entry = input;

          const ftcheck = document.createElement('input');
          ftcheck.type = 'checkbox';
          ftcheck.ariaLabel = 'full-text toggle';
          ftcheck.style.position = 'absolute';
          ftcheck.style.top = '42px';
          ftcheck.style.left = '231px';
          ftcheck.style.display = 'none';
          ftcheck.id = idPrefix + 'FTCheck';
          // ftcheck.onclick = ftclicked;
          this.ft = ftcheck;

          const ftlabel = document.createElement('label');
          ftlabel.setAttribute('for', idPrefix + 'FTCheck');
          ftlabel.style.position = 'absolute';
          ftlabel.style.top = '46px';
          ftlabel.style.left = '213px';
          ftlabel.innerHTML = 'FT';
          ftlabel.style.display = 'none';
          ftlabel.style.fontFamily = 'helvetica, arial, sans-serif';
          ftlabel.style.zIndex = 999;

          const loading = document.createElement('div');
          loading.id = this.idPrefix + 'Loading';
          // loading.src = "images/loading2.gif";
          loading.style.position = 'absolute';
          loading.style.top = '39px';
          loading.style.right = '44px';
          loading.style.display = 'none';
          loading.style.height = '18px';
          loading.style.width = '18px';
          loading.style.zIndex = 999;
          // let loading = document.createElement("div");
          // loading.innerHTML = '<svg class="spinner" viewBox="0 0 50 50"><circle class="path" cx="25" cy="25" r="20" fill="none" stroke-width="10"></circle></svg>';
          loading.innerHTML = '<div class="lds-spinner"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div>';

          this.loading = loading;

          this.closedNodeImg = 'images/plus.gif';
          this.openNodeImg = 'images/minus.gif';

          input.onkeydown = wordtreeOnDown;
          input.onkeyup = wordtreeOnUp;

          this.div.appendChild(ftcheck);
          this.div.appendChild(ftlabel);
          this.div.appendChild(input);
          this.div.appendChild(loading);

          const con = document.createElement('div');
          con.classList.add('WordContainer');
          con.id = idPrefix + 'Container';

          con.style.top = this.conTopOffset + 'px';
          con.style.width = this.width - 20 + 'px';

          /*
          if (con.addEventListener) {
                  con.addEventListener('DOMMouseScroll', onMouseWheel, false);
                  con.addEventListener("mousewheel", onMouseWheel, false);
          }
          else if (con.attachEvent) {
                  con.attachEvent("onmousewheel", onMouseWheel);
          }
          */

          con.onscroll = conOnScroll;
          if (platform === 'ipad' || platform === 'iphone' || (navigator.maxTouchPoints && navigator.maxTouchPoints > 1)) {
            con.ontouchstart = onTouch;
          }
          const wt = this;
          d.onclick = function () { if (wt.entry && wt.autofocus) wt.entry.focus(); };
          this.div.appendChild(con);

          this.con = con;

          globalWordTrees.push([idPrefix, this]);

          this.show = wordtreeShow;
          this.close = destroyWT;
          this.setHeight = setHeight;
          this.setWidth = setWidth;
          this.centerSelectedRow = centerSelectedRow;
          this.refresh = refreshWordTree;
          this.refreshWithRows = refreshWithRows;
          this.requestNextPage = requestNextPage;
          this.requestPrevPage = requestPrevPage;
          this.clearWordTree = clearWordTree;
          this.requestRows = requestRows;
          this.clearCache = clearCache;
          this.cache = null;
          this.cacheCount = 0;
          this.getColumnValues = getColumnValues;

          this.f = null;
          this.dragDest = null;

          this.onEnterActivate = null;
          this.onClickActivate = null;
          this.onSelectionChanged = null;
          this.onAddWord = null;
          this.onDeleteWord = null;

          this.openAllNodes = openAllNodes;
          this.closeAllNodes = closeAllNodes;

          this.setHeight(height);
          this.setWidth(width);
          this.makeQueryURL = makeQueryURL;

          function clearWordTree () {
            const con = this.con;
            let a = con.firstChild;
            while (a) {
              const b = a.nextSibling;
              con.removeChild(a);
              a = b;
            }
            this.selectedRow = null;
            this.rowCount = 0;
          }

          function setHeight (height) {
            this.height = height;
            this.div.style.height = (height - 7) + 'px';
            this.con.style.height = (height - 22 - this.conTopOffset) + 'px';
          }

          function setWidth (width) {
            this.width = width;
            this.con.style.width = (width - 20) + 'px';
            if (this.entry) { this.entry.style.width = (width - 67) + 'px'; }
            this.div.style.width = width - 1 + 'px';
          }

          function refreshWithRows (rows) {
            this.lastRequestTime = 0; // defeat sequence check
            procResponse(rows, 'success');
          }

          function makeQueryURL (page, query) {
            const requestTime = new Date().getTime();
            let requestPage = 0;
            if (page < 0) {
              requestPage = parseInt(this.pageUp) + page;
            } else if (page > 0) {
              requestPage = parseInt(this.page) + page;
            }

            return this.url + '?n=' + (this.maxWords + 1) +
              '&idprefix=' + this.idPrefix +
              '&x=' + Math.random() +
              '&requestTime=' + requestTime +
              '&page=' + requestPage +
              '&mode=' + this.mode +
              '&query=' + query;
          }

          function refreshWordTree () {
            this.loading.style.display = 'block';

            if (checkCache(this)) { return; }

            if (this.entry) { this.params.w = this.entry.value; }
            let query = JSON.stringify(this.params);
            query = encodeURIComponent(query);
            if (fullText) {
              fullTextRequest(this.entry.value);
            } else {
              this.page = 0;
              const url = this.makeQueryURL(0, query);
              requestRows(url);
            }
          }

          function requestNextPage () {
            this.loading.style.display = 'block';
            if (this.entry) { this.params.w = this.entry.value; }
            let query = JSON.stringify(this.params);
            query = encodeURIComponent(query);
            const url = this.makeQueryURL(1, query);
            requestRows(url);
          }

          function requestPrevPage () {
            this.loading.style.display = 'block';
            if (this.entry) { this.params.w = this.entry.value; }
            let query = JSON.stringify(this.params);
            query = encodeURIComponent(query);
            const url = this.makeQueryURL(-1, query);
            requestRows(url);
          }

          function wordtreeShow (parent) {
            parent.appendChild(this.div);
          }

          function onTouch (e) {
            const wt = lookupWT('test1');
            if (!wt) {
              return;
            }

            if (!wt.autofocus) {
              wt.entry.blur();
            }
          }

          function conOnScroll (e) {
            // increase this number to fetch next page earlier (for slower connections if there is a lag when you hit the end of the last page),
            // decrease if it's being fetched to soon
            const whenToGetNextPage = 400;

            // this = the container element
            const match = /(.*)Container/.exec(this.id);
            if (!match) {
              return;
            }

            const wt = lookupWT(match[1]);
            if (!wt) {
              return;
            }

            // don't request another page if we're on the last page OR if another nextPageRequest is pending.
            // don't increase page until it is received and appropriate
            if (wt.con.scrollTop > wt.con.scrollHeight - wt.con.offsetHeight - whenToGetNextPage && !wt.nextPageRequestPending && !wt.lastPage && !wt.blockScroll) {
              wt.nextPageRequestPending = true;
              wt.requestNextPage();
            } else if (wt.mode === 'context' && wt.con.scrollTop < whenToGetNextPage && !wt.prevPageRequestPending && !wt.lastPageUp && !wt.blockScroll) {
              wt.prevPageRequestPending = true;
              wt.requestPrevPage();
            }
          }

          function wordtreeOnUp (ev) {
            if (!ev) { ev = window.event; }

            const key = ev.keyCode;

            const match = /(.*)Entry/.exec(this.id);
            if (!match) { return; }
            const idPrefix = match[1];

            const wt = lookupWT(idPrefix);
            if (!wt) { return; }

            clearTimeout(wt.accelTimeout);
            wt.accelTimeout = null;
            wt.step = 1;
            wt.downkey = false;

            if (wt.scrollTimer) {
              if (wt.scrollTimerTimeout) { clearTimeout(wt.scrollTimerTimeout); }
              wt.scrollTimerTimeout = false;
              wt.scrollTimerKeyDown = false;
            }
            /*
            //temp for testing paging without actually paging
            if (key == 78) {
              wt.prevPageRequestPending = true;
              wt.requestPrevPage();
            }
            */

            if (key === 40 || key === 38) {
              if (typeof wt.onSelectionChanged === 'function' && wt.selectedRow) {
                wt.onSelectionChanged(wt.params.lexicon, getColumnValues(wt.selectedRow));
              }
            } else if (!ev.ctrlKey && (((key >= 48 && key <= 90) || key === 8 || key === 46) || key === 0) && wt.asYouType) {
              // block fast typers from making requests for every keystroke
              wt.page = 0;
              wt.selectedRow = null;

              if (wt.lastKeyTimeout) { clearTimeout(wt.lastKeyTimeout); }
              wt.lastKeyTimeout = setTimeout(function () { lookupWT(wt.idPrefix).refresh(); }, keyDelay);
            } else if (key === 27) { // esc
              /*
                    if (wt.entry.value == "")
            {
                alert("a: " + wt.entry.value);
                        wt.params.tag_id = 0;
                    }
                    */
              /*
        wt.entry.value = "";
        wt.page = 0;
        wt.selectedRow = null;

        //block fast typers from making requests for every keystroke
        if (wt.lastKeyTimeout)
            clearTimeout(wt.lastKeyTimeout);
        wt.lastKeyTimeout = setTimeout("let a = lookupWT('" + wt.idPrefix + "'); a.refresh(); if (a.entry && a.autofocus) a.entry.focus()", keyDelay);
            */
            }
          }

          function wordtreeOnDown (ev) {
            const key = ev.keyCode;

            if (key === 17) {
              return;
            }

            const match = /(.*)Entry/.exec(this.id);
            if (!match) {
              return;
            }
            const idPrefix = match[1];

            const wt = lookupWT(idPrefix);
            if (!wt) {
              return;
            }

            if (key === 39) { // right arrow: open row
              if (wt.selectedRow && wt.selectedRow.id) {
                // first open row
                if (!openNode(wt, wt.selectedRow.id)) {
                  // on second key press open row's children
                  wt.openAllNodes(wt.selectedRow.nextSibling);
                }
              }
            } else if (key === 37) { // left arrow: close row
              if (wt.selectedRow && wt.selectedRow.id) {
                closeNode(wt, wt.selectedRow.id);
                wt.closeAllNodes(wt.selectedRow.nextSibling);
                /*
                    if (!closeNode(wt, wt.selectedRow.id))
                    {
                        wt.closeAllNodes(wt.selectedRow.nextSibling);
                    }
                    */
              }
            } else if (key === 38) {
              if (wt.scrollTimer) {
                if (!wt.scrollTimerKeyDown) {
                  if (!wt.scrollTimerTimeout && wt.step > 1) { wt.scrollTimerTimeout = setTimeout(function () { wt.scrollTimerKeyDown = true; move(1, wt, wt.step); }, wt.scrollTimerDelay); }

                  move(1, wt, wt.step);
                }
              } else {
                move(1, wt, wt.step);
                // accelerate
                if (!wt.downkey) {
                  wt.accelTimeout = setTimeout(function () { const a = lookupWT(wt.idPrefix); a.step = 2; a.accelTimeout = setTimeout(function () { lookupWT('test1').step = keyScrollAccel; }, 2000); }, 2000);
                }
              }
            } else if (key === 40) {
              if (wt.scrollTimer) {
                if (!wt.scrollTimerKeyDown) {
                  if (!wt.scrollTimerTimeout && wt.step > 1) { wt.scrollTimerTimeout = setTimeout(function () { wt.scrollTimerKeyDown = true; move(-1, wt, wt.step); }, wt.scrollTimerDelay); }

                  move(-1, wt, wt.step);
                }
              } else {
                move(-1, wt, wt.step);
                // accelerate
                if (!wt.downkey) {
                  wt.accelTimeout = setTimeout(function () { const a = lookupWT(wt.idPrefix); a.step = 2; a.accelTimeout = setTimeout(function () { lookupWT('test1').step = keyScrollAccel; }, 2000); }, 2000);
                }
              }
            }

            if (!wt.downkey) {
              // put non-repeating downkey stuff here
              if (ev.ctrlKey) {
                if (key === 65) { // a
                  if (typeof wt.onAddWord === 'function' && wt.selectedRow) {
                    wt.onAddWord(wt.params.lexicon, getColumnValues(wt.selectedRow));
                    ev.returnValue = false;
                    ev.preventDefault();
                  }
                }
                if (key === 68) { // d
                  if (typeof wt.onDeleteWord === 'function' && wt.selectedRow) {
                    wt.onDeleteWord(getColumnValues(wt.selectedRow)[1], getColumnValues(wt.selectedRow)[2], wt.params.tag_id);
                    ev.returnValue = false;
                    ev.preventDefault();
                  }
                }
                if (key === 69) { // e
                  if (wt.selectedRow) { toggleNode(wt, wt.selectedRow.id); }

                  // block default hot keys, like bookmark, etc
                  ev.returnValue = false;
                  ev.preventDefault();
                }
              }

              switch (key) {
                case 17: // control
                  ev.returnValue = false;
                  ev.preventDefault();
                  return false;
                case 13: // enter
                  // alert(wt.asYouType);
                  if (!wt.asYouType) {
                    // alert(wt.url);
                    wt.refresh();
                  } else if (typeof wt.onEnterActivate === 'function' && wt.selectedRow) {
                    // alert("a" + wt.url);
                    wt.onEnterActivate(wt.params.lexicon, getColumnValues(wt.selectedRow));
                  }
                  break;
                case 27: // esc
                  // clear tags if no text to clear
                  if (wt.entry.value === '') {
                    wt.params.tag_id = 0;
                  }
                  wt.entry.value = '';
                  wt.page = 0;
                  wt.selectedRow = null;

                  // block fast typers from making requests for every keystroke
                  if (wt.lastKeyTimeout) { clearTimeout(wt.lastKeyTimeout); }
                  wt.lastKeyTimeout = setTimeout(function () { const a = lookupWT(wt.idPrefix); a.refresh(); if (a.entry && a.autofocus) a.entry.focus(); }, keyDelay);
                  break;
                default:
                  break;
              }
            }

            wt.downkey = true;
            if (!ev.ctrlKey && !ev.metaKey && (wt.params.lexicon === 'lsj' || wt.params.lexicon === 'slater')) {
              return transliterateKey(ev);
            } else {
              return true;
            }
          }

          function move (upDown, wt, step) {
            const con = wt.con;
            let n;
            let lastGoodn = null;

            if (!wt.selectedRow) {
              n = con.firstChild;
            } else if (upDown > 0) { // up
              if (wt.selectedRow !== con.firstChild) {
                n = wt.selectedRow;
                /*
                do {
                  n = stepUp(n);
                } while (n && n.parentNode.style.display == "none");
                */
                for (let i = 0; n && i < step; i++) {
                  lastGoodn = n;
                  n = stepUp(n);
                }

                if (!n) { n = lastGoodn; }
              }
            } else { // down
              if (wt.selectedRow !== con.lastChild) {
                n = wt.selectedRow;
                /*
                do {
                  n = stepDown(n);
                } while (n && n.parentNode.style.display == "none");
                */
                let i = 0;
                for (; n && i < step; i++) {
                  lastGoodn = n;
                  n = stepDown(n);
                }

                if (!n) { n = lastGoodn; }
              }
            }

            if (!n) {
              return;
            }

            if (wt.selectedRow) {
              if (wt.selectedRow.classList.contains('selectedRowClass')) {
                wt.selectedRow.classList.remove('selectedRowClass');
              }
            }

            n.classList.add('selectedRowClass');

            if (wt.dragSource) {
              n.setAttribute('draggable', true);
              n.addEventListener('dragstart', wt.dragStartFunc, false);
            }

            let childOffset = n.offsetTop;
            let temp = n.parentNode;

            // this is needed because n.offSetTop does not work if the node is buried in 2 deep -Children divs
            while (temp.id.indexOf('Container') === -1) { // this means we can't use "Container" as a prefix name
              // s += " + " + temp.id + " (" + temp.offsetTop + ") ";
              // t += " + " + temp.offsetTop;
              childOffset += temp.offsetTop;
              temp = temp.parentNode; // or temp.offsetParent? both seem to work
            }
            // document.getElementById("t").innerHTML = s + "<br><br>" + t + " = " + (childOffset);

            // scroll as you go up
            if (childOffset < con.scrollTop + 30) { // was 15
              con.scrollTop = childOffset - 30; // was 18
            }

            // scroll as you go down
            if (childOffset > con.scrollTop + con.offsetHeight - 50) { // was 30
              con.scrollTop = childOffset - con.offsetHeight + 50; // was 40
            }

            wt.selectedRow = n;

            function stepDown (n) {
              if (!n) { return null; }

              // now with hierarchies the upper node could the start of a Child container or we could be leaving a child container
              let p = n.parentNode;

              while (n) {
                n = n.nextSibling;

                if (n && n.id.indexOf('Children') !== -1) {
                  if (n.style.display === 'none') { continue; }

                  n = n.firstChild;
                }
                break;
              }

              if (!n) {
                while (p && p.id.indexOf('Children') !== -1) {
                  if (p.nextSibling) {
                    n = p.nextSibling;
                    break;
                  }
                  p = p.parentNode;
                }
              }
              return n;
            }

            function stepUp (n1) {
              if (!n1) { return null; }

              let n = n1.previousSibling;
              while (n && n.id.indexOf('Children') !== -1) {
                if (n.style.display === 'none') {
                  n = n.previousSibling;
                  continue;
                }

                n = n.lastChild;
              }

              if (!n && n1.parentNode.id.indexOf('Container') === -1) {
                n = n1.parentNode.previousSibling;
              }
              return n;
            }

            if (wt.scrollTimer && wt.scrollTimerKeyDown) {
              setTimeout(function () { move(upDown, wt, wt.scrollTimerStep); }, wt.scrollTimerRate);
            }
          }

          /*
            row object key:
            i = id
            r = row an array for the different columns
            h = has_children
            c = array of row objects for this row's children
            o = open row
            s = sequence

            eventually lexicon, query, and tag_id will be put into a single field for requests
            */
          // a two column response
          // let resp2 = '{"wtprefix":"test1","container":"test1Container","requestTime":"99999","selectId":"0","page":"0","lastPage":"0","lastPageUp":"1","scroll":"top","query":"a","cols":"2","arrOptions":[{"i":1,"r":["Α","abc"]},{"i":5,"r":["ἃ","abc"]},{"i":2,"r":["ἀ1","abc"]},{"i":20395,"r":["α1","abc"]},{"i":3,"r":["ἀ2","abc"]},{"i":102761,"r":["α2","abc"]},{"i":4,"r":["ἆ3","abc"]},{"i":6,"r":["ἄα","abc"]},{"i":8,"r":["ἀάβακτοι","abc"]},{"i":9,"r":["ἀαγής","abc"]}]}';
          // let resp2 = '{"error":"","wtprefix":"test1","nocache":"0","container":"test1Container","requestTime":"1631672832851","selectId":"0","page":"0","lastPage":"0","lastPageUp":"1","scroll":"top","query":"","arrOptions":[{"i":0,"r":["Α α",0,0]},{"i":1,"r":["ἀ-",1,0]},{"i":2,"r":["ἀ-",2,0]},{"i":3,"r":["ἆ",3,0]},{"i":4,"r":["ἃ ἃ",4,0]},{"i":5,"r":["ἄα",5,0]},{"i":6,"r":["ἀάατος",6,0]},{"i":7,"r":["ἀάβακτοι",7,0]},{"i":8,"r":["ἀαγής",8,0]},{"i":9,"r":["ἄαδα",9,0]},{"i":10,"r":["ἀάζω",10,0]},{"i":11,"r":["ἄαθι",11,0]},{"i":12,"r":["ἀάκατος",12,0]},{"i":13,"r":["ἀακίδωτος",13,0]},{"i":14,"r":["ἀάλιον",14,0]},{"i":15,"r":["ἀανές",15,0]},{"i":16,"r":["ἄανθα",16,0]},{"i":17,"r":["ἀάπλετος",17,0]},{"i":18,"r":["ἄαπτος",18,0]},{"i":19,"r":["ἄας",19,0]},{"i":20,"r":["ἀασιφόρος",20,0]},{"i":21,"r":["ἀασιφρονία",21,0]},{"i":22,"r":["ἀασιφροσύνη",22,0]},{"i":23,"r":["ἀάσκει",23,0]},{"i":24,"r":["ἀασμός",24,0]},{"i":25,"r":["ἀάσπετος",25,0]},{"i":26,"r":["ἀάστονα",26,0]},{"i":27,"r":["ἀατήρ",27,0]},{"i":28,"r":["ἄατος",28,0]},{"i":29,"r":["ἄατος",29,0]},{"i":30,"r":["ἀάτυλον",30,0]},{"i":31,"r":["ἀάω",31,0]},{"i":32,"r":["ἄβα",32,0]},{"i":33,"r":["ἄβαγνα",33,0]},{"i":34,"r":["ἀβαθής",34,0]},{"i":35,"r":["ἄβαθρος",35,0]},{"i":36,"r":["ἀβαίνω",36,0]},{"i":37,"r":["ἀβακέω",37,0]},{"i":38,"r":["ἀβακηνούς",38,0]},{"i":39,"r":["ἀβακής",39,0]},{"i":40,"r":["ἀβάκητον",40,0]},{"i":41,"r":["ἀβακίζομαι",41,0]},{"i":42,"r":["ἀβάκιον",42,0]},{"i":43,"r":["ἀβακίσκος",43,0]},{"i":44,"r":["ἀβακλή",44,0]},{"i":45,"r":["ἀβακοειδής",45,0]},{"i":46,"r":["ἄβακτον",46,0]},{"i":47,"r":["ἀβάκχευτος",47,0]},{"i":48,"r":["ἀβακχίωτος",48,0]},{"i":49,"r":["ἄβαλε",49,0]},{"i":50,"r":["ἀβαμβάκευτος",50,0]},{"i":51,"r":["ἄβαξ",51,0]},{"i":52,"r":["ἀβάπτιστος",52,0]},{"i":53,"r":["ἄβαπτος",53,0]},{"i":54,"r":["ἀβαρβάριστος",54,0]},{"i":55,"r":["ἀβαρής",55,0]},{"i":56,"r":["ἄβαρις",56,0]},{"i":57,"r":["ἀβασάνιστος",57,0]},{"i":58,"r":["ἀβασίλευτος",58,0]},{"i":59,"r":["ἀβασκάνιστος",59,0]},{"i":60,"r":["ἀβάσκανος",60,0]},{"i":61,"r":["ἀβάσκαντος",61,0]},{"i":62,"r":["ἀβάστακτος",62,0]},{"i":63,"r":["ἄβαστον",63,0]},{"i":64,"r":["ἀβατόομαι",64,0]},{"i":65,"r":["ἄβατος",65,0]},{"i":66,"r":["ἀβαφής",66,0]},{"i":67,"r":["ἄβδελον",67,0]},{"i":68,"r":["ἀβδέλυκτος",68,0]},{"i":69,"r":["Ἀβδηρίτης",69,0]},{"i":70,"r":["ἄβδης",70,0]},{"i":71,"r":["ἀβέβαιος",71,0]},{"i":72,"r":["ἀβεβαιότης",72,0]},{"i":73,"r":["ἀβέβηλος",73,0]},{"i":74,"r":["ἄβεις",74,0]},{"i":75,"r":["ἄβελλον",75,0]},{"i":76,"r":["ἀβελτέρειος",76,0]},{"i":77,"r":["ἀβελτερεύομαι",77,0]},{"i":78,"r":["ἀβελτερία",78,0]},{"i":79,"r":["ἀβελτεροκόκκυξ",79,0]},{"i":80,"r":["ἀβέλτερος",80,0]},{"i":81,"r":["ἀβέρβηλον",81,0]},{"i":82,"r":["ἀβηδών",82,0]},{"i":83,"r":["ἀβήρελ",83,0]},{"i":84,"r":["ἀβηροῦσιν",84,0]},{"i":85,"r":["ἀβίαστος",85,0]},{"i":86,"r":["ἀβίβαστος",86,0]},{"i":87,"r":["ἀβίβλης",87,0]},{"i":88,"r":["ἄβιδα",88,0]},{"i":89,"r":["ἄβιν",89,0]},{"i":90,"r":["ἄβιος",90,0]},{"i":91,"r":["ἄβιος",91,0]},{"i":92,"r":["ἀβίοτος",92,0]},{"i":93,"r":["ἀβίυκτον",93,0]},{"i":94,"r":["ἀβιωτοποιός",94,0]},{"i":95,"r":["ἀβίωτος",95,0]},{"i":96,"r":["ἀβλάβεια",96,0]},{"i":97,"r":["ἀβλαβής",97,0]},{"i":98,"r":["ἀβλαβία",98,0]},{"i":99,"r":["ἀβλαβύνιον",99,0]},{"i":100,"r":["ἄβλαπτος",100,0]}]}';

          function procResponse (str, status) {
            // let start = Date.now();

            // if (status != "success")
            // return;

            let returnObj;
            // str = resp2;
            // console.log("Proc Response: " + str);
            // if (str.indexOf("test4") > -1)
            // alert(str);
            try {
              if (typeof JSON !== 'undefined') {
                returnObj = JSON.parse(str);
              } else {
                // console.log("browser does not support json decode");
                return;// returnObj = eval("(" + str + ")");
              }
            } catch (e) { if (debug) alert(e.message + '\n' + str); return; };

            if (!returnObj) {
              return;
            }

            const wt = lookupWT(returnObj.wtprefix);
            if (!wt) {
              return;
            }

            if (returnObj.mesgCode) {
              // alert(returnObj.mesg);
              const z = document.getElementById('mesg');
              if (z) {
                if (returnObj.mesgCode === 1) {
                  z.style.backgroundColor = 'green';
                  z.style.paddingTop = '12px';
                  z.style.color = 'white';
                  z.innerHTML = returnObj.mesg;
                } else {
                  z.style.backgroundColor = 'red';
                  z.style.paddingTop = '12px';
                  z.style.color = 'white';
                  z.innerHTML = returnObj.mesg;
                }
                z.style.display = 'block';
                setTimeout(function () { document.getElementById('mesg').style.display = 'none'; }, 2000);
              }
              return;
            }

            wt.loading.style.display = 'none';
            wt.blockScroll = true;

            // if caching is activated, add result to cache
            if (wt.cache && returnObj.nocache === 0) { // the only one we don't cache is if if it's looked up via wordid
              wtAddResultToCache(wt, returnObj.query, str);
            }

            if (debug && returnObj.error) {
              wt.con.innerHTML = returnObj.error;
              wt.blockScroll = false;
              return;
            }

            // save original height here, for use if we're paging up.    See below.
            const saveHeight = wt.con.scrollHeight;

            // block result sets which come out of sequence
            if (wt.lastRequestTime > parseInt(returnObj.requestTime)) {
              // if (debug) {
              //         console.log("out of seq!");
              // }
              wt.blockScroll = false;
              return;
            } else {
              // set lastRequestTime to that of the last result set received
              wt.lastRequestTime = parseInt(returnObj.requestTime);
            }

            const returnedPage = parseInt(returnObj.page);

            // block pages which are repeats or out of order
            if (returnedPage < 0 && returnedPage >= wt.pageUp) {
              // if (debug) {
              //         console.log("wt.pageUp: " + wt.pageUp + "; returnObj.page: " + returnObj.page);
              // }

              wt.blockScroll = false;
              return;
            } else if (returnedPage > 0 && returnedPage <= wt.pageUp) {
              // if (debug) {
              //         console.log("wt.pageDown: " + wt.page + "; returnObj.pageDown: " + returnObj.page);
              // }

              wt.blockScroll = false;
              return;
            }

            const con = document.getElementById(returnObj.container);

            const arrOptions = returnObj.arrOptions;
            const len = arrOptions.length;

            if (returnedPage < 0) {
              wt.pageUp = returnedPage;
              wt.prevPageRequestPending = false;
            } else if (returnedPage === 0) {
              // reset these if we just refreshed a page 0
              wt.page = 0;
              wt.pageUp = 0;
            } else {
              wt.page = returnedPage;
              wt.nextPageRequestPending = false;
            }

            if (returnObj.parentid) { // && returnObj.treeOptions.length > 0)
              let i = 0;
              for (; i < len; i++) {
                // insertBefore, roots, and selectedId are both false because this function is only for inserting
                // non-top-level items lazily
                printTree(wt, con, arrOptions[i], 1, false, false, -1);
              }

              if (returnObj.selectId) {
                const node = document.getElementById(returnObj.selectId);
                if (node) {
                  node.classList.add('selectedRowClass');
                  wt.selectedRow = node;
                }
              }
              if (wt.entry && wt.autofocus) {
                wt.entry.focus();
              }

              wt.blockScroll = false;
            } else {
              // only set these if not a tree branch
              if (returnObj.lastPage === 1) { wt.lastPage = true; }
              if (returnObj.lastPage === 0) { wt.lastPage = false; }

              if (returnObj.lastPageUp === 1) { wt.lastPageUp = true; }
              if (returnObj.lastPageUp === 0) { wt.lastPageUp = false; }

              // delete old rows if this is page 0 and this isn't a tree
              if (returnedPage === 0 && !returnObj.parentid) {
                wt.clearWordTree();
              }

              // if (debug) {
              //   const node = document.createElement('div');
              //   const text = document.createTextNode('Start Page ' + returnObj.page);
              //   node.appendChild(text);
              //   node.style.border = '1px solid white';
              //   node.id = '10blahWord';
              //   node.style.whiteSpace = 'nowrap';
              //   node.style.color = 'red';
              //   node.style.fontWeight = 'bold';
              //   if (returnObj.page < 0 && before) { con.insertBefore(node, before); } else { con.appendChild(node); }
              // }
              let i = 0;
              for (; i < len; i++) {
                let insertBefore = false;
                if (returnedPage < 0) {
                  insertBefore = true;
                }

                printTree(wt, con, arrOptions[i], 0, insertBefore, returnObj.roots, returnObj.selectId);
                // printRow(wt, con, arrOptions[i], 0, insertBefore, returnObj.roots, returnObj.selectId);
              }

              if (wt && returnObj.selectId === 0) {
                wt.con.scrollTop = '0'; // scrollTop does not use "px", just 0
              } else if (wt && returnObj.selectId && returnedPage === 0) {
                // select middle word and scroll there
                const s = document.getElementById(wt.selectedRowId);
                if (s) {
                  if (wt.selectedRow) {
                    if (wt.selectedRow.classList.contains('selectedRowClass')) {
                      wt.selectedRow.classList.remove('selectedRowClass');
                    }
                  }
                  s.classList.add('selectedRowClass');
                  wt.selectedRow = s;

                  if (wt.dragSource) {
                    s.setAttribute('draggable', true);
                    s.addEventListener('dragstart', wt.dragStartFunc, false);
                  }

                  wt.centerSelectedRow();
                }
              }

              // if (debug) {
              //   const node = document.createElement('div');
              //   const text = document.createTextNode('End Page ' + returnObj.page);
              //   node.appendChild(text);
              //   node.id = '10blahWord';
              //   node.style.border = '1px solid white';
              //   // node.setAttribute('class','treerow');
              //   node.style.whiteSpace = 'nowrap';
              //   node.style.color = 'red';
              //   node.style.fontWeight = 'bold';
              //   if (returnedPage < 0 && before) { con.insertBefore(node, before); } else { con.appendChild(node); }
              // }

              if (returnedPage < 0) {
                // to keep scrollTop in same place as before when paging up.
                wt.con.scrollTop += (wt.con.scrollHeight - saveHeight);
              }
              wt.blockScroll = false; // fixes bug in webkit where next page was requested in middle of this function

              // request def
              if (wt.selectedRow && returnedPage === 0 && typeof wt.onSelectionChanged === 'function') { wt.onSelectionChanged(wt.params.lexicon, getColumnValues(wt.selectedRow)); }
            }

            // topLevelTreeRow tells us to indent rows with no children the width of the plus sign,
            // so they line up with the rows that do have children.
            function printRow (wt, con, rowItem, level, insertAtTop, topLevelTreeRow, selectedId) {
              const node = document.createElement('div');
              node.classList.add('nodestyle');
              node.setAttribute('rowid', wt.rowCount + wt.idPrefix);
              node.id = wt.rowCount++ + wt.idPrefix;

              node.onclick = onSelect;

              if (wt.dragDest) {
                node.addEventListener('dragover', wt.overFunc, false);
                node.addEventListener('dragenter', wt.enterFunc, false); // to get IE to work
                node.addEventListener('dragleave', wt.leaveFunc, false);
                node.addEventListener('drop', wt.dropFunc, false);
              }

              // for each column
              const rowLen = rowItem.length;
              for (let c = 0; c < rowLen; c++) {
                const d2 = document.createElement('div');
                d2.classList.add('nodestylecol');

                if (c !== 0 && wt.columnOffsets[c] === 0) { d2.style.display = 'none'; } else { d2.style.left = wt.columnOffsets[c] + 'px'; }

                if (level === 0) { d2.style.paddingLeft = 1 + (!rowItem.h && topLevelTreeRow ? 15 : 3) + 'px'; } else { d2.style.paddingLeft = (level * wt.indentWidth) + (rowItem.h ? 3 : 15) + 'px'; }

                if (c === 0 && rowItem.h) { // only for column 1
                  const img = document.createElement('img');
                  if (!rowItem.o) { img.src = wt.closedNodeImg; } else { img.src = wt.openNodeImg; }
                  img.style.display = 'inline';
                  img.style.paddingRight = '4px';
                  img.style.cursor = 'pointer';
                  img.id = node.id + 'Img';
                  img.onclick = openCloseCon;
                  d2.appendChild(img);
                }

                const text = document.createTextNode(rowItem[c]);
                d2.appendChild(text);
                node.appendChild(d2);
              }

              if (rowItem[1] === selectedId) {
                wt.selectedRowId = node.id;
              }

              const before = con.firstChild;
              if (insertAtTop && before) { con.insertBefore(node, before); } else { con.appendChild(node); }
            }

            function openCloseCon (ev) {
              ev.cancelBubble = true;
              if (ev.stopPropagation) ev.stopPropagation();

              // "this" is a reference to the img node
              const match = parseNodeImgId(this.id);
              if (!match) { return; }

              const wtprefix = match.wtPrefix;
              const wordid = match.id;
              const wt = lookupWT(wtprefix);

              if (wt) {
                toggleNode(wt, wordid + wtprefix);
              }
            }

            function onSelect (ev) {
              const res = parseNodeId(this.id);
              if (!res) { return; }

              const idPrefix = res.wtPrefix;

              const w = lookupWT(idPrefix);

              if (w.selectedRow) {
                w.selectedRow.setAttribute('draggable', false);

                if (w.selectedRow.classList.contains('selectedRowClass')) {
                  w.selectedRow.classList.remove('selectedRowClass');
                }
              }

              this.classList.add('selectedRowClass');

              if (w.dragSource) {
                this.setAttribute('draggable', true);
                this.addEventListener('dragstart', w.dragStartFunc, false);
              }

              w.selectedRow = this;

              if (typeof w.onClickActivate === 'function') {
                w.onClickActivate(w.params.lexicon, getColumnValues(this));
                // console.log("select: " + w.params.lexicon + ", " + getColumnValues(this));
              }
              if (w.entry && wt.autofocus) { w.entry.focus(); }
            }

            function printTree (wt, con, treeRow, level, insertBefore, roots, selectedId) {
              printRow(wt, con, treeRow, level, insertBefore, roots, selectedId);

              if (treeRow.h && treeRow.c) {
                let node2 = document.createElement('div');
                node2.style.position = 'relative';
                if (!treeRow.o) { node2.style.display = 'none'; }
                node2 = con.appendChild(node2);
                node2.id = node2.previousSibling.id + 'Children';

                const treeRowLen = treeRow.c.length;
                for (let i = 0; i < treeRowLen; i++) {
                  printTree(wt, node2, treeRow.c[i], level + 1, insertBefore, roots, selectedId);
                }
              }
            }
          }

          function toggleNode (wt, nodeid) {
            const imgId = nodeid + 'Img';
            const imgNode = document.getElementById(imgId);

            if (!imgNode) { // its ok for n to be null (lazy load)
              return;
            }

            if (imgNode.src.indexOf(wt.closedNodeImg) !== -1) {
              openNode(wt, nodeid);
            } else {
              closeNode(wt, nodeid);
            }
            if (wt.entry && wt.autofocus) { wt.entry.focus(); }
          }

          /**
             * Return true if node was opened.    False otherwise.
             * This lets us open all, on second keypress.
             */
          function openNode (wt, nodeid) {
            const childrenConId = nodeid + 'Children';
            const imgId = nodeid + 'Img';
            const n = document.getElementById(childrenConId);
            const imgNode = document.getElementById(imgId);

            if (!imgNode) { // its ok for n to be null, but not imgNode
              return true;
            }

            if (imgNode.src.indexOf(wt.openNodeImg) !== -1) { return false; }

            imgNode.src = wt.openNodeImg;

            if (n) {
              n.style.display = 'block';
            } else { // lazy load children...
              const requestTime = new Date().getTime();
              const childrenCon = document.createElement('div');
              childrenCon.style.position = 'relative';

              childrenCon.id = childrenConId;

              if (imgNode.parentNode.parentNode.nextSibling) { wt.con.insertBefore(childrenCon, imgNode.parentNode.parentNode.nextSibling); } else { wt.con.appendChild(childrenCon); }

              wt.params.root_id = parseInt(getColumnValues(document.getElementById(nodeid))[1]);

              if (wt.selectedRow) { wt.params.selectedid = wt.selectedRow.id; } // maybe this should just be nodeid?
              let query = wt.makeQuery(wt.params);
              query = encodeURIComponent(query);

              const url = wt.url + '?n=' + (wt.maxWords + 1) + '&idprefix=' + wt.idPrefix + '&x=' + Math.random() + '&requestTime=' + requestTime + '&page=' + wt.page + '&con=' + childrenConId + '&mode=' + wt.mode + '&query=' + query;

              requestRows(url);
              wt.params.root_id = 0;
              wt.params.selectedid = 0;
            }
            return true;
          }

          /**
           * Return true if node was closed. False otherwise.
           * This lets us close all, on second keypress.
           */
          function closeNode (wt, nodeid) {
            const childrenConId = nodeid + 'Children';
            const imgId = nodeid + 'Img';
            const n = document.getElementById(childrenConId);
            const imgNode = document.getElementById(imgId);

            if (!n || !imgNode) {
              return true;
            }

            if (imgNode.src.indexOf(wt.closedNodeImg) !== -1) {
              return false;
            }

            n.style.display = 'none';
            imgNode.src = wt.closedNodeImg;

            return true;
          }

          function openAllNodes (node) {
            const children = node.childNodes;
            const regex = new RegExp('^[0-9]+' + this.idPrefix + '$');
            const childLen = children.length;
            for (let i = 0; i < childLen; i++) {
              if (children[i].childNodes.length > 0) { this.openAllNodes(children[i]); }

              if (regex.exec(children[i].id)) { openNode(this, children[i].id); }
            }
          }

          function closeAllNodes (node) {
            if (node) {
              const children = node.childNodes;
              const regex = new RegExp('^[0-9]+' + this.idPrefix + '$');
              const childLen = children.length;
              for (let i = 0; i < childLen; i++) {
                if (children[i].childNodes.length > 0) { this.closeAllNodes(children[i]); }

                if (regex.exec(children[i].id)) { closeNode(this, children[i].id); }
              }
            }
          }

          function requestRows (url) {
            microAjax({
              url,
              method: 'GET',
              success: procResponse,
              warning: procResponseError,
              error: null
            });
          }

          function procResponseError (str) {
            if (typeof JSON !== 'undefined') {
              const returnObj = JSON.parse(str);
              if (typeof (returnObj.error) !== 'undefined') {
                console.log('response error: ' + returnObj.error);
                // wt.loading.style.display = "none";
              }
            }
          }

          function checkCache (wt) {
            if (!wt.entry) { return false; }

            let queryKey = '';
            if (wt.entry.value === '') { queryKey = wt.params.lexicon + '' + wt.params.tag_id; } else { queryKey = wt.params.lexicon + wt.entry.value + wt.params.tag_id; }

            if (wt.cache && wt.cache[queryKey]) {
              wt.lastRequestTime = 0; // defeat sequence check
              procResponse(wt.cache[queryKey].str, 'success');
              return true;
            } else {
              return false; // not cached, request it
            }
          }

          function clearCache () {
            this.cache = [];
          }

          function wtAddResultToCache (wt, queryKey, str) {
            // the queryKey is the lexicon + the query word
            queryKey = wt.params.lexicon + queryKey + wt.params.tag_id;
            // if this query isn't in the cache
            if (!wt.cache[queryKey]) {
              // if we're at the cacheLimit remove the oldest item
              // (shorter keys are more useful results to have so maybe we should give them added importance?)
              // use cacheLength because assoc arrays have no length property and we don't want to have to count them each time
              if (cacheLimit && wt.cacheLength >= cacheLimit) {
                let prev = null;
                for (const x in wt.cache) {
                  if (typeof wt.cache.hasOwn === 'function' && !wt.cache.hasOwn(x)) { continue; }

                  if (prev == null || wt.cache[x].time < wt.cache[prev].time) { prev = x; }
                }
                if (prev) {
                  wt.cacheLength--;
                  delete wt.cache[prev];
                }
              }
              wt.cacheLength++;
              wt.cache[queryKey] = [];
              wt.cache[queryKey].str = str;
              if (queryKey === wt.params.lexicon + 'a' || queryKey === wt.params.lexicon + 'α') { // put empty queries into the future, so they are never removed from cache
                const d = new Date();
                d.setDate(d.getDate() + 5);
                wt.cache[queryKey].time = d.getTime();
              } else { wt.cache[queryKey].time = new Date().getTime(); }
            } else if (queryKey !== wt.params.lexicon + 'a' || queryKey === wt.params.lexicon + 'α') { // don't reset timestamp for empty query
              // if it is in the cache, update the timestamp
              wt.cache[queryKey].time = new Date().getTime();
            }
          }

          function centerSelectedRow () {
            if (this.selectedRow) {
              // scroll to middle
              this.con.scrollTop = this.selectedRow.offsetTop - (this.con.offsetHeight / 2) + 30;
            }
          }
        }

        /*
        wtprefix
        rowscon = wtprefix + "Container"
        imageid = word/root_id + wtprefix + "Img"
        rowchidren = word/rootid + wtprefix + "Children"
        */
        function parseNodeId (id) {
          let r = null;
          const match = /([0-9]+)(.*)/.exec(id);
          if (match) {
            r = {};
            r.id = match[1];
            r.wtPrefix = match[2];
          }
          return r;
        }

        function parseNodeImgId (id) {
          let r = null;
          const match = /([0-9]+)(.+)Img/.exec(id);
          if (match) {
            r = {};
            r.id = match[1];
            r.wtPrefix = match[2];
          }
          return r;
        }

        function getColumnValues (row) {
          const values = [];
          let col = row.firstChild;

          for (let i = 0; col; i++) {
            const match = /.*Img/.exec(col.firstChild.id); // in case it has a + or - image
            if (match) { values[i] = col.firstChild.nextSibling.nodeValue; } else { values[i] = col.firstChild.nodeValue; }
            col = col.nextSibling;
          }
          return values;
        }
        /* end wordtree.js */
    </script>
</body>
</html>
